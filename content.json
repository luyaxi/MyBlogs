{"pages":[],"posts":[{"title":"常用函数","text":"整理了一些常用函数。 二分查找，若找到则返回下标，否则返回最后失败的位置，要求原序列有序。 1234567891011121314151617181920int BinarySearch(int a[], int key, int lo, int hi){ int i, mi; while (lo &lt; hi) { mi = (lo + hi) &gt;&gt; 1; if (key &lt; a[mi]) { hi = mi; } else { lo = mi + 1; } } if (a[lo - 1] != key) { return -1; } return --lo;} 冒泡排序，稳定的排序算法，时间复杂度O(n^2),空间复杂度O(1)。 12345678910111213141516void BubbleSort(int * arr, int n){ int i, j; for (i = 0; i &lt; n; i++) { for (j = 0;j&lt;n-1;j++) { if (Comp(&amp;arr[j], &amp;arr[j+1])) { Swap(&amp;arr[j],&amp;arr[j+1]); } } }} 归并排序，稳定的排序算法，时间复杂度O(nlogn),空间复杂度O(n)。这里给的递归实现。 12345678910111213141516171819202122232425262728void merge(int* arr, int lo, int mi, int hi){ int* A = arr + lo; int lb = mi - lo; int* B = (int*)malloc(sizeof(int)*lb); int i; for (i = 0; i &lt; lb; B[i] = A[i++]); int lc = hi - mi; int* C = arr + mi; for (i = 0, j = 0, k = 0; j &lt; lb;) { if ((k &lt; lc) &amp;&amp; (C[k] &lt; B[j])) A[i++] = C[k++]; if (lc &lt;= k || (B[j] &lt;= C[k])) A[i++] = B[j++]; } delete[] B;}void mergesort(int* arr, int lo, int hi){ if (hi - lo &lt; 2) return; int mi = (lo + hi) &gt;&gt; 1; mergesort(arr, lo, mi); mergesort(arr, mi, hi); merge(arr, lo, mi, hi);}","link":"/2019/12/21/%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/"},{"title":"若干个1,跳格子问题,玩游戏二","text":"期中考试摸了，遇到两个奇怪的问题。 若干个1和跳楼梯 第一个问题 对任意n，如果n对2的余数和n对5的余数不为零，则存在n的倍数为若干个1。 123456789101112131415161718192021222324252627282930313233#include &lt;stdio.h&gt;int len(long long n);int main() { int n; scanf(\"%d\", &amp;n); long long i = 1; if (n % 2 != 0 &amp;&amp; n % 5 != 0) { while (i % n != 0) { i *= 10; i += 1; } printf(\"%d\", len(i)); } return 0;}int len(long long n) { int length = 0; if (n &gt;= 0 &amp;&amp; n &lt; 10) return 1; while (n &gt; 0) { length++; n /= 10; } return length;} 问题思考一开始就应该带上优化的想法，从111出发而非从倍数出发。 第二个问题 跳楼梯，输入n（1&lt; n &lt; 100 ），每次能跳1，2，3个阶梯，求总方法数。 显然不能用递归，重复度太高，所以采用dp的思想，迭代解决。 123456789101112131415161718192021#include &lt;stdio.h&gt;int main() { int n; scanf(\"%d\", &amp;n); int i = 1; int a = 1; int b = 2; int c = 4; int t; for (i = 4; i &lt;= n; i++) { t = a + b + c; a = b; b = c; c = t; } printf(\"%d\", t); return 0;} 状态的转移是这里唯一的考点，对到达第i阶楼梯，可以从i-1（a），i-2（b），i-3（c）三种状态到达，最终的效果就是在O(n)时间内解决问题。 另外还有一道简单的模拟题，如何把给定的操作化成数值的变化是考点。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;stdio.h&gt;int check(long long n);int len(long long n);int main() { char c; int x=0,y=0,dir=0; while((c=getchar())!='\\n'){ if(c=='1'){ if(dir%2==0){ x=x+dir-1; }else{ y=y+dir-2; } } if(c=='2'){ if(dir-1&lt;0) { dir = 3; }else{ dir=dir-1; } if(dir%2==0){ x=x+dir-1; }else{ y=y+dir-2; } } if (c=='3'){ dir=(dir+1)%4; if(dir%2==0){ x=x+dir-1; }else{ y=y+dir-2; } } } if(x==0||y==0){ if(x&lt;0) printf(\"w\"); if(x&gt;0) printf(\"e\"); if(y&gt;0) printf(\"n\"); if(y&lt;0) printf(\"s\"); }else{ if(x&gt;0&amp;&amp;y&gt;0) printf(\"en\"); if(x&gt;0&amp;&amp;y&lt;0) printf(\"es\"); if(x&lt;0&amp;&amp;y&gt;0) printf(\"nw\"); if(x&lt;0&amp;&amp;y&lt;0) printf(\"sw\"); } return 0;}","link":"/2019/11/15/%E8%8B%A5%E5%B9%B2%E4%B8%AA1,%E8%B7%B3%E6%A0%BC%E5%AD%90%E9%97%AE%E9%A2%98,%E7%8E%A9%E6%B8%B8%E6%88%8F%E4%BA%8C/"},{"title":"蛇形矩阵","text":"#蛇形矩阵# 问题描述：蛇形矩阵是一个nn的矩阵，将整数1到nn按照蛇形的顺序装入一个 n*n 的蛇形矩阵中，如样例所示分别为5阶和10阶蛇形矩阵： 输入与输出要求：输入一个整数n，代表蛇形矩阵的阶数，n的范围是1—100。输出蛇形矩阵。每行的每个元素用空格分隔，注意最后一个数的后面为换行符。 程序运行效果：Sample 1：5 1 3 4 10 112 5 9 12 196 8 13 18 207 14 17 21 2415 16 22 23 25 这题的关键在蛇形上，千万不能暴力的一点点模拟，否则判断冗长且易错。不断的模拟这个过程，发现这玩意爬的方向和所在对角线的奇偶性有关；其次，每个对角线上数字的个数也于对角线的序号有关。这样便能写出上面那个三角形。而这上下是有镜像关系的，故直接对称的来一次即可解决问题。 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;stdio.h&gt;int matrix[105][105];void fill(int n);int main() { int n, i, j; scanf(\"%d\", &amp;n); fill(n); for (i = 0; i &lt; n ; i++) { for (j = 0; j &lt; n-1; j++) { printf(\"%d \", matrix[i][j]); } printf(\"%d\\n\", matrix[i][n - 1]); } return 0;}void fill(int n) { int i, j; int p = 1, max = n * n; for (i = 0; i &lt; n ; i++) { for (j = 0; j &lt;= i; j++) { if (i % 2 == 0) matrix[j][i - j] = p++; else matrix[i - j][j] = p++; } } for (i = 0; i &lt; n ; i++) { for (j = 0; j &lt;= i; j++) { if (i % 2 == 0) matrix[n - 1 - j][n - 1 - i + j] = max--; else matrix[n - 1 - i + j][n - 1 - j] = max--; } }}","link":"/2019/11/26/%E8%9B%87%E5%BD%A2%E7%9F%A9%E9%98%B5/"}],"tags":[{"name":"infomation","slug":"infomation","link":"/tags/infomation/"},{"name":"Question","slug":"Question","link":"/tags/Question/"}],"categories":[]}