{"pages":[],"posts":[{"title":"常用函数","text":"整理了一些常用函数。 二分查找，若找到则返回下标，否则返回最后失败的位置，要求原序列有序。 12345678910111213141516int BinarySearch(int a[], int key, int lo, int hi){ int mi; while (lo &lt; hi) { mi = (lo + hi) &gt;&gt; 1; if (key &lt; a[mi]) { hi = mi; } else { lo = mi + 1; } } return --lo;} 冒泡排序，稳定的排序算法，时间复杂度O(n^2),空间复杂度O(1)。 12345678910111213141516void BubbleSort(int * arr, int n){ int i, j; for (i = 0; i &lt; n; i++) { for (j = 0;j&lt;n-1;j++) { if (Comp(&amp;arr[j], &amp;arr[j+1])) { Swap(&amp;arr[j],&amp;arr[j+1]); } } }} 归并排序，稳定的排序算法，时间复杂度O(nlogn),空间复杂度O(n)。这里给的递归实现。 12345678910111213141516171819202122232425262728void merge(int* arr, int lo, int mi, int hi){ int* A = arr + lo; int lb = mi - lo; int* B = (int*)malloc(sizeof(int)*lb); int i,j,k; for (i = 0; i &lt; lb; B[i] = A[i++]); int lc = hi - mi; int* C = arr + mi; for (i = 0, j = 0, k = 0; j &lt; lb;) { if ((k &lt; lc) &amp;&amp; (C[k] &lt; B[j])) A[i++] = C[k++]; if (lc &lt;= k || (B[j] &lt;= C[k])) A[i++] = B[j++]; } delete[] B;}void mergesort(int* arr, int lo, int hi){ if (hi - lo &lt; 2) return; int mi = (lo + hi) &gt;&gt; 1; mergesort(arr, lo, mi); mergesort(arr, mi, hi); merge(arr, lo, mi, hi);}","link":"/2019/12/21/%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/"},{"title":"若干个1,跳格子问题,玩游戏二","text":"期中考试摸了，遇到两个奇怪的问题。 若干个1和跳楼梯 第一个问题 对任意n，如果n对2的余数和n对5的余数不为零，则存在n的倍数为若干个1。 123456789101112131415161718192021222324252627282930313233#include &lt;stdio.h&gt;int len(long long n);int main() { int n; scanf(\"%d\", &amp;n); long long i = 1; if (n % 2 != 0 &amp;&amp; n % 5 != 0) { while (i % n != 0) { i *= 10; i += 1; } printf(\"%d\", len(i)); } return 0;}int len(long long n) { int length = 0; if (n &gt;= 0 &amp;&amp; n &lt; 10) return 1; while (n &gt; 0) { length++; n /= 10; } return length;} 问题思考一开始就应该带上优化的想法，从111出发而非从倍数出发。 第二个问题 跳楼梯，输入n（1&lt; n &lt; 100 ），每次能跳1，2，3个阶梯，求总方法数。 显然不能用递归，重复度太高，所以采用dp的思想，迭代解决。 123456789101112131415161718192021#include &lt;stdio.h&gt;int main() { int n; scanf(\"%d\", &amp;n); int i = 1; int a = 1; int b = 2; int c = 4; int t; for (i = 4; i &lt;= n; i++) { t = a + b + c; a = b; b = c; c = t; } printf(\"%d\", t); return 0;} 状态的转移是这里唯一的考点，对到达第i阶楼梯，可以从i-1（a），i-2（b），i-3（c）三种状态到达，最终的效果就是在O(n)时间内解决问题。 另外还有一道简单的模拟题，如何把给定的操作化成数值的变化是考点。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;stdio.h&gt;int check(long long n);int len(long long n);int main() { char c; int x=0,y=0,dir=0; while((c=getchar())!='\\n'){ if(c=='1'){ if(dir%2==0){ x=x+dir-1; }else{ y=y+dir-2; } } if(c=='2'){ if(dir-1&lt;0) { dir = 3; }else{ dir=dir-1; } if(dir%2==0){ x=x+dir-1; }else{ y=y+dir-2; } } if (c=='3'){ dir=(dir+1)%4; if(dir%2==0){ x=x+dir-1; }else{ y=y+dir-2; } } } if(x==0||y==0){ if(x&lt;0) printf(\"w\"); if(x&gt;0) printf(\"e\"); if(y&gt;0) printf(\"n\"); if(y&lt;0) printf(\"s\"); }else{ if(x&gt;0&amp;&amp;y&gt;0) printf(\"en\"); if(x&gt;0&amp;&amp;y&lt;0) printf(\"es\"); if(x&lt;0&amp;&amp;y&gt;0) printf(\"nw\"); if(x&lt;0&amp;&amp;y&lt;0) printf(\"sw\"); } return 0;}","link":"/2019/11/15/%E8%8B%A5%E5%B9%B2%E4%B8%AA1,%E8%B7%B3%E6%A0%BC%E5%AD%90%E9%97%AE%E9%A2%98,%E7%8E%A9%E6%B8%B8%E6%88%8F%E4%BA%8C/"},{"title":"多文件编译问题","text":"在c语言中，由于各编译器的差别，导致对多文件编译的格式支持出现问题。 这学期老师让我们开发一个模拟cpu的程序，本想着多写几个模块最后拼起来，各种include之后报错几百个。当成差点吐血。后来研究了一下，发现是编译器支持的问题。我先是用vscode和mingw64简单编译了一下，移植到visual studio时出现问题。 经实验，vscode和mingw64支持的多文件编译格式是这样的。 12345678910111213141516171819202122232425262728293031//a.h文件#ifndef A_H #define A_H #include &lt;stdio.h&gt;#define len 64struct a{ int x[len];};void printa(struct a* sa){ printf(\"%d\",sa-&gt;x[0]);}#endif//b.h文件#ifndef B_H#define B_H#include \"a.h\"struct b{ char x[len*4];};void printb(struct a* sa,struct b* sb){ printa(sa); printf(\"%c\",sb-&gt;x);}#endif 也就是说，头文件中的宏定义，函数，结构体都是通用的。在b.h中包含a.h后，编译器在b.h中能识别到a.h中的所有内容。 再来看visual studio的情况。报错LNK 2005，查了下官方的说明，发现其不支持vscode+mingw64的编译方式。若想在其中使用多文件编译，要这么写: 123456789101112131415161718192021222324252627282930313233343536//a.h文件#pragma once#include &lt;stdio.h&gt;#define len 64struct a{ int x[len];};void printa(struct a* sa);//a.c文件#include \"a.h\"void printa(struct a* sa){ printf(\"%d\",sa-&gt;x[0]);}//b.h文件#pragma once#include \"a.h\"struct b{ char x[len*4];};void printb(struct a* sa,struct b* sb);//b.c文件#include \"b.h\"void printb(struct a* sa,struct b* sb){ printa(sa); printf(\"%c\",sb-&gt;x);} 可以看出，和上面的区别就是函数的实现要和声明分开，实现要放到和所在头文件同名的.c文件中，编译器会自动链接函数。其中 1#pragma once 换成 123#ifndef xx #define xx #endif 也可。同样起到避免重复编译的情况。 总结一下，vscode+mingw64不支持自动链接函数，可以把函数的定义写在头文件中，而visualStudio支持，并且强制要把函数的声明和定义分开放在两个文件中。","link":"/2020/03/31/%E5%A4%9A%E6%96%87%E4%BB%B6%E7%BC%96%E8%AF%91%E9%97%AE%E9%A2%98/"},{"title":"蛇形矩阵","text":"#蛇形矩阵# 问题描述：蛇形矩阵是一个nn的矩阵，将整数1到nn按照蛇形的顺序装入一个 n*n 的蛇形矩阵中，如样例所示分别为5阶和10阶蛇形矩阵： 输入与输出要求：输入一个整数n，代表蛇形矩阵的阶数，n的范围是1—100。输出蛇形矩阵。每行的每个元素用空格分隔，注意最后一个数的后面为换行符。 程序运行效果：Sample 1：5 1 3 4 10 112 5 9 12 196 8 13 18 207 14 17 21 2415 16 22 23 25 这题的关键在蛇形上，千万不能暴力的一点点模拟，否则判断冗长且易错。不断的模拟这个过程，发现这玩意爬的方向和所在对角线的奇偶性有关；其次，每个对角线上数字的个数也于对角线的序号有关。这样便能写出上面那个三角形。而这上下是有镜像关系的，故直接对称的来一次即可解决问题。 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;stdio.h&gt;int matrix[105][105];void fill(int n);int main() { int n, i, j; scanf(\"%d\", &amp;n); fill(n); for (i = 0; i &lt; n ; i++) { for (j = 0; j &lt; n-1; j++) { printf(\"%d \", matrix[i][j]); } printf(\"%d\\n\", matrix[i][n - 1]); } return 0;}void fill(int n) { int i, j; int p = 1, max = n * n; for (i = 0; i &lt; n ; i++) { for (j = 0; j &lt;= i; j++) { if (i % 2 == 0) matrix[j][i - j] = p++; else matrix[i - j][j] = p++; } } for (i = 0; i &lt; n ; i++) { for (j = 0; j &lt;= i; j++) { if (i % 2 == 0) matrix[n - 1 - j][n - 1 - i + j] = max--; else matrix[n - 1 - i + j][n - 1 - j] = max--; } }}","link":"/2019/11/26/%E8%9B%87%E5%BD%A2%E7%9F%A9%E9%98%B5/"}],"tags":[{"name":"infomation","slug":"infomation","link":"/tags/infomation/"},{"name":"Question","slug":"Question","link":"/tags/Question/"},{"name":"Information","slug":"Information","link":"/tags/Information/"}],"categories":[]}